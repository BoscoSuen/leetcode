/*
 * @lc app=leetcode id=924 lang=java
 *
 * [924] Minimize Malware Spread
 */

// @lc code=start
class Solution {
    /*
Union found all nodes.
Count the union size of each union set.
Count the malware number of each union set.

Return the biggest union's malware if there is one and only one malware.
If no such union that has and has only one malware,
return the malware with minimum index.
time: O(n^2)
    */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        if (graph == null || graph.length == 0) return 0;
        int n = graph.length;
        int[] parent = new int[n];
        for (int i = 0; i < n; ++i) {
            parent[i] = i;
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j] == 1) {
                    union(parent, i, j);
                }
            }
        }
        int[] ufSize = new int[n];
        int[] initCount = new int[n];
        for (int i = 0; i < n; ++i) {
            ufSize[find(parent, i)]++;
        }
        for (int init : initial) {
            initCount[find(parent, init)]++;
        }
        int res = -1;
        Arrays.sort(initial);
        int max = 0;
        for (int init : initial) {
            int root = find(parent, init);
            if (initCount[root] == 1 && ufSize[root] > max) {
                max = ufSize[root];
                res = init;
            }
        }
        return max == 0 ? initial[0] : res;
    }

    private void union(int[] parent, int x, int y) {
        int px = find(parent, x);
        int py = find(parent, y);
        if (px != py) {
            parent[py] = px;
        }
    }

    private int find(int[] parent, int x) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
}
// @lc code=end

